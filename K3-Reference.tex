\documentclass{article}

\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage{stmaryrd}
\usepackage{todonotes}

\usepackage{K3-Reference}

\hypersetup{colorlinks,linkcolor=orange}

\title{K3: Language Reference}
\author{}
\date{}

\newcommand{\K}{\texttt{K3}}

\begin{document}
    \maketitle

    \tableofcontents

    \todototoc
    \listoftodos

    \section{Code Generation}
    \subsection{Imperative Targets}

    Code generation to imperative target languages is done in two stages. The first is a pure $\K
    \rightarrow \K$ transformation which produces an imperative embedding, more amenable to
    translation into an imperative language. The second stage consists of the actual translation to
    the backing language.

    \subsubsection{Grammar Constructs}

    The rewrite rules for the first stage are as follows:

    \subsubsection{Declaration Rules}

    \begin{itemize}
        \item Triggers rewrite to functions of the corresponding argument types.
        \item Global variable declarations rewrite to declarations of the same type, with the caveat
            that collection declarations are rewritten to be of a type specific to the combination
            of annotations they are declared with.
        \item Annotation declarations rewrite to global declaration of composites, which consist of
            the relevant lifted attributes and methods.
    \end{itemize}
%
    \begin{align*}
        \eqI{\gtDeclare x \gtColon \tau \gtIs e}
            {\gtDeclare x \gtColon \tau \gtIs \intI{e}}
            {if $\tau$ is not a collection type.} \\
        \eqI{\gtDeclare x \gtColon \tau \gtIs e}
            {\gtDeclare x \gtColon \gtNamed \ConstructComposite{ids} \gtIs \intI{e}}
            {if $\tau \sim \gtCollection \gtAt \{ids\}$.} \\
        \eqI{\gtTrigger x \gtColon \tau \gtIs e}
            {\gtDeclare x \gtColon \tau \gtArrow \gtLP \gtRP \gtIs e}
            {} \\
        \eqI{\gtAnnotation A \gtGiven \gtLP t_1 \gtComma \ldots \gtComma t_n \gtRP \gtLB \bar{D} \gtRB}
            {\gtAnnotation A \gtGiven \gtLP t_1 \gtComma \ldots \gtComma t_n \gtRP \gtLB \intI{\bar{D}} \gtRB}{} \\
        \eqI{\gtProvides \gtLifted x \gtColon \tau \gtIs e}
            {\gtProvides \gtLifted x \gtColon \tau \gtIs \intI{e}}{} \\
        \eqI{\gtRequires \gtLifted x \gtColon \tau}
            {\gtRequires \gtLifted x \gtColon \tau}{} \\
        \eqI{\gtProvides x \gtColon \tau \gtIs e}
            {\gtProvides x \gtColon \tau \gtIs \intI{e}}{} \\
        \eqI{\gtRequires x \gtColon \tau}
            {\gtRequires x \gtColon \tau}{} \\
        \eqI{\gtProvides \gtAnnotation a}
            {\gtProvides \gtAnnotation a}{} \\
        \eqI{\gtRequires \gtAnnotation a}
            {\gtRequires \gtAnnotation a}{}
    \end{align*}

    \subsubsection{Expression Rules}

    \begin{itemize}
        \item Value constructors (constants of any type, \texttt{Some}/\texttt{None}, indirections,
            literal tuples and records, \texttt{empty}) should be reified with a generated name.
        \item Binary operators except function application can remain as-is.
        \item Function declaration/application has two forms:
            \begin{itemize}
                \item If the function is anonymous (and is therefore immediately applied), it should
                    be rewritten as a \texttt{let-in}.
                \item If the function is declared globally (and is therefore potentially applied
                    multiple times), it should be translated into a native function, with
                    corresponding invocations translated as native function calls.
            \end{itemize}
    \end{itemize}
%
    \begin{align*}
        \eqI{e_1 \oplus e_2}{\intI{e_1} \oplus \intI{e_2}}{where $\oplus \neq \epsilon$ or $e_1$ is a variable.} \\
        \eqI{\gtLP \lambda x \gtArrow e_1 \gtRP e_2}{\gtLet x \gtAssign \gtImmut \intI{e_2} \gtIn \intI{e_1}}{} \\
        \eqI{\gtSome e}{\gtSome \intI{e}}{} \\
        \eqI{\gtInd e}{\gtInd \intI{e}}{} \\
        \eqI{\gtLP e_1, e_2, \ldots, e_n \gtRP}{\gtLP \intI{e_1}, \intI{e_2}, \ldots, \intI{e_n} \gtRP}{} \\
        \eqI{\gtLP x_1 \gtColon e_1, x_2 \gtColon e_2, \ldots, x_n \gtColon e_n \gtRP}
            {\gtLP x_1 \gtColon \intI{e_1}, x_2 \gtColon \intI{e_2}, \ldots, x_n \gtColon \intI{e_n} \gtRP}{} \\
        \eqI{\gtIf e_1 \gtThen e_2 \gtElse e_3}{\gtIf \intI{e_1} \gtThen \intI{e_2} \gtElse \intI{e_3}}{} \\
        \eqI{e.x}{\intI{e}.x}{} \\
        \eqI{\gtLet x \gtAssign e_1 \gtIn e_2}{\gtLet x \gtAssign \intI{e_1} \gtIn \intI{e_2}}{} \\
        \eqI{x \gtAssign e}{x \gtAssign \intI{e}}{} \\
        \eqI{\gtCase e_1 \gtOf \gtLB \gtSome x \gtArrow e_2 \gtRB
                \gtLB \gtNone \gtArrow e_3 \gtRB}
            {\gtCase \intI{e_1} \gtOf \gtLB \gtSome x \gtArrow \intI{e_2} \gtRB
                \gtLB \gtNone \gtArrow \intI{e_3} \gtRB}
            {} \\
        \eqI{\gtBind e_1 \gtAs b \gtIn e_2}{\gtBind \intI{e_1} \gtAs b \gtIn \intI{e_2}}{} \\
        \eqI{e}{e}{otherwise.}
    \end{align*}

    \subsection{\texttt{C++} Generation}

    Following the imperative transformation, \texttt{C++} code generation takes place through
    stringification.

    \subsubsection{Expression Rules}

    When generating \texttt{C++} code for \texttt{K3} expressions, we must address the problem of
    how to make use of intermediate storage for results. While most expressions can be inlined, some
    (e.g.~\texttt{if-then-else}) require that their results be stored in an intermediate location
    while others (e.g.~the left operand of a sequence operator) do not care about their results
    whatsoever.

    In this scenario, we can define four different ways in which the result of an expression might
    be handled.

    \begin{description}
        \item[By Inlining:] The most common method is to inline the result of the sub-expression
            into its position in the calling context. Most expressions follow this form.
        \item[By Name:] Some expressions cannot provide their result inline, as the syntactic form
            of the result might not be known until runtime (e.g.~\texttt{if-then-else}). In this
            case, the expression must reify its result in a named variable, which it can pass up to
            its calling context.
        \item[By Return:] If the result of an expression is the return value of a generated
            function, its result need not be stored in an intermediate. Instead, the value can be
            returned directly.
            \sn{Return Reification}{Unless of course the expression requires that the result be
                stored in an intermediate.  (e.g.~$\gtSome$, $\gtInd$), in which case, how does
                allocation work in the return context?}
        \item[By Forgetting:] If the result is not used, it need not be stored at all (e.g.~the left
            operand of a sequence operator).
    \end{description}

    The last three forms of reification share a similar structure in \texttt{C++}. Each form can be
    expressed as an effect which reifies the result appropriately. To simplify the treatment of the
    various reification forms in the code generation rules, we define the reification statement
    $R_\delta$ as follows:
%
    \begin{align*}
        R_\delta(v) = \begin{cases}
            \gtReturn v & \delta = \textsc{Return} \\
            k \gtIs v & \delta = \textsc{Named$(k)$} \\
            \phi & \delta = \textsc{Forget}
        \end{cases}
    \end{align*}

    For the purposes of generating code, we define the family of derivation relations $\rwD$, where
    $\delta \in \{\textsc{Inline}, \textsc{Named$(k)$}, \textsc{Return}, \textsc{Forget}\}$. Some
    expressions lend themselves naturally to the inline form, and for such rules the reified form
    can be derived mechanically. Alternately, other expressions lend themselves naturally to the
    reified form, where the reverse is possible. These two canonical rules are as follows:
%
    \begin{mathpar}
        \inferrule[Canonical/$\delta$]{%
                e \rwI (E, V)
            }{%
                e \rwD (E \gtSemi R_\delta(V), \phi)
            }

        \inferrule[Canonical/Inline]{%
                \Fresh{k} \\
                e \rw{N(k)} (E, \phi)
            }{%
                e \rwI (E, k)
            }
    \end{mathpar}

    Therefore it is generally only necessary to specify one of the rules (\textsc{Inline} or
    otherwise) for each expression. These rules are as follows:
%
    \begin{mathpar}
        \inferrule[Constant/Inline]{%
                \\
            }{%
                c \rwI (\phi, c)
            }

        \inferrule[Variable/Inline]{%
                \\
            }{%
                v \rwI (\phi, v)
            }

        \inferrule[Some/Inline]{%
                e \rwI (e_E, e_V) \\
                \Fresh{x}
            }{%
                \gtSome e \rwI (e_E \gtSemi x \gtAssign e_V, \gtAmp x)
            }

        \inferrule[Indirection/Inline]{%
                e \rwI (e_E, e_V) \\
                \Fresh{x}
            }{%
                \gtInd e \rwI (e_E \gtSemi x \gtAssign e_V, \gtAmp x)
            }

        \inferrule[Tuple/Inline]{%
                e_1 \rwI (e_{1,E}, e_{1,V}) \\
                e_2 \rwI (e_{2,E}, e_{2,V}) \\
                \cdots \\
                e_n \rwI (e_{n,E}, e_{n,V})
            }{%
                \gtLP e_1 \gtComma e_2 \gtComma \ldots \gtComma e_n \gtRP \rwI
                    (e_{1,E} \gtSemi e_{2,E} \gtSemi \ldots \gtSemi e_{n,E},
                    \gtLP e_{1,V} \gtComma e_{2,V} \gtComma \ldots \gtComma e_{n,V} \gtRP)
            }

        \inferrule[Record/Inline]{%
                e_1 \rwI (e_{1,E}, e_{1,V}) \\
                e_2 \rwI (e_{2,E}, e_{2,V}) \\
                \cdots \\
                e_n \rwI (e_{n,E}, e_{n,V})
            }{%
                \gtLB x_1 \gtColon e_1 \gtComma x_2 \gtColon e_2 \gtComma \ldots \gtComma x_n \gtColon e_n \gtRB
                    \rwI (e_{1,E} \gtSemi e_{2,E} \gtSemi \ldots \gtSemi e_{n,E},
                        \gtLB x_1 \gtColon e_{1,V} \gtComma
                              x_2 \gtColon e_{2,V} \gtComma \ldots \gtComma
                              x_n \gtColon e_{n,V}
                        \gtRB)
            }

        \inferrule[Unary/Inline]{%
                e \rwI (e_E, e_V)
            }{%
                \oplus e \rwI (e_E, \oplus e_V)
            }

        \inferrule[Binary/Inline]{%
                a \rwI (a_E, a_V) \\
                b \rwI (b_E, b_V)
            }{%
                a \oplus b \rwI (a_E \gtSemi b_E, a_V \oplus b_V)
            }

        \inferrule[Project/Inline]{%
                e \rwI (e_E, e_V)
            }{%
                e.x \rwI (e_E, e_V.x)
            }


        \inferrule[Let-In/$\delta$]{%
                a \rwI (a_E, a_V) \\
                b \rwD (b_E, \phi)
            }{%
                \gtLet x \gtAssign a \gtIn b \rwD
                    (a_E \gtSemi \gtLB x \gtAssign a_V \gtSemi b_E \gtRB, \phi)
            }

        \inferrule[Assign/Inline]{%
                e \rw{N(x)} (e_E, \phi)
            }{%
                x \gtAssign e \rwI (e_E, \gtNull)
            }

        \inferrule[Case-Of/$\delta$]{%
                e \rwI (e_E, e_V) \\
                a \rwD (a_E, \phi) \\
                b \rwD (b_E, \phi)
            }{%
                \gtCase e \gtOf \gtLB \gtSome x \gtArrow a \gtRB \gtLB \gtNone \gtArrow b \gtRB \rwD
                    (e_E \gtSemi \gtIf \gtLP e_V \gtNeq \gtNull \gtRP
                        \gtLB x \gtAssign \gtStar e_V \gtSemi a_E \gtRB \gtElse
                        \gtLB b_E \gtRB, \phi)
            }

        % TODO: Specify that x_1 ... x_n must use the reference form of get, and must be references
        % themselves.
        \inferrule[Bind-Indirection/$\delta$]{%
                e \rwI (e_E, e_V) \\
                b \rwD (b_E, \phi)
            }{%
                \gtBind e \gtAs \gtInd x \gtIn b \rwD
                    (e_E \gtSemi \gtLB x \gtAssign \gtStar e_V \gtSemi b_E \gtRB, \phi)
            }

        \inferrule[Bind-Tuple/$\delta$]{%
                e \rwI (e_E, e_V) \\
                b \rwD (b_E, \phi)
            }{%
                \gtBind e \gtAs \gtLP x_1 \gtComma \ldots \gtComma x_n \gtRP \gtIn b \rwD
                    (e_E \gtSemi \gtLB
                        x_1 \gtAssign \ccall{get}{0}{e_V} \gtSemi
                        \ldots \gtSemi
                        x_n \gtAssign \ccall{get}{n - 1}{e_V} \gtSemi
                        b_E
                    \gtRB, \phi)
            }

        \inferrule[Bind-Record/$\delta$]{%
                e \rwI (e_E, e_V) \\
                b \rwD (b_E, \phi)
            }{%
                \gtBind e \gtAs \gtLB x_1 \gtColon y_1 \gtComma \ldots \gtComma x_n \gtColon y_n \gtRB \gtIn b
                    \rwD (e_E \gtSemi \gtLB
                        y_1 \gtAssign e_V.x_1 \gtSemi
                        \ldots \gtSemi
                        y_n \gtAssign e_V.x_n \gtSemi
                        b_E
                    \gtRB, \phi)
            }

        \inferrule[If-Then-Else/$\delta$]{%
                p \rwI (p_E, p_V) \\
                t \rwD (t_E, \phi) \\
                e \rwD (e_E, \phi)
            }{%
                \gtIf p \gtThen t \gtElse e \rwD
                    (p_E \gtSemi \gtIf \gtLP p_V \gtRP \gtLB t_E \gtRB \gtLB e_E \gtRB, \phi)
            }
    \end{mathpar}
\end{document}
