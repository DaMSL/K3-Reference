\documentclass{article}

\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{fullpage}
\usepackage{K3-Reference}

\title{K3: Language Reference}
\author{}
\date{}

\newcommand{\K}{\texttt{K3}}

\begin{document}
    \maketitle

    \tableofcontents

    \section{Code Generation}
    \subsection{Imperative Targets}

    Code generation to imperative target languages is done in two stages. The first is a pure $\K
    \rightarrow \K$ transformation which produces an imperative embedding, more amenable to
    translation into an imperative language. The second stage consists of the actual translation to
    the backing language.

    \subsubsection{Grammar Constructs}

    The rewrite rules for the first stage are as follows:

    \subsubsection{Declaration Rules}

    \begin{itemize}
        \item Triggers rewrite to functions of the corresponding argument types.
        \item Global variable declarations rewrite to declarations of the same type, with the caveat
            that collection declarations are rewritten to be of a type specific to the combination
            of annotations they are declared with.
        \item Annotation declarations rewrite to global declaration of composites, which consist of
            the relevant lifted attributes and methods.
    \end{itemize}
%
    \begin{align}
        \intI{\gtDeclare x \gtColon \tau \gtIs e}
            &= \gtDeclare x \gtColon \tau \gtIs \intI{e}
            \; \text{if $\tau$ is not a collection type.} \\
        \intI{\gtDeclare x \gtColon \tau \gtIs e}
            &= \gtDeclare x \gtColon \gtNamed \ConstructComposite{ids} \gtIs \intI{e}
            \; \text{if $\tau \sim \gtCollection \gtAt \{ids\}$.} \\
        \intI{\gtProvides \gtLifted x \gtColon \tau \gtIs e}
            &= \gtDeclare x \gtColon \tau \gtIs e
    \end{align}

    \subsubsection{Expression Rules}

    \begin{itemize}
        \item Value constructors (constants of any type, \texttt{Some}/\texttt{None}, indirections,
            literal tuples and records, \texttt{empty}) should be reified with a generated name.
        \item Binary operators except function application can remain as-is.
        \item Function declaration/application has two forms:
            \begin{itemize}
                \item If the function is anonymous (and is therefore immediately applied), it should
                    be rewritten as a \texttt{let-in}.
                \item If the function is declared globally (and is therefore potentially applied
                    multiple times), it should be translated into a native function, with
                    corresponding invocations translated as native function calls.
            \end{itemize}
    \end{itemize}
%
    \begin{align}
        \intI{e_1 \oplus e_2}
            &= \intI{e_1} \oplus \intI{e_2} \;\; \text{where $\oplus \neq \epsilon$ or $e_1$ is a variable.} \\
        \intI{\gtLP \lambda x \gtArrow e_1 \gtRP e_2}
            &= \gtLet x \gtAssign \gtImmut \intI{e_2} \gtIn \intI{e_1} \\
        \intI{\gtSome e}
            &= \gtSome \intI{e} \\
        \intI{\gtInd e}
            &= \gtInd \intI{e} \\
        \intI{\gtLP e_1, e_2, \ldots, e_n \gtRP}
            &= \gtLP \intI{e_1}, \intI{e_2}, \ldots, \intI{e_n} \gtRP \\
        \intI{\gtLP x_1 \gtColon e_1, x_2 \gtColon e_2, \ldots, x_n \gtColon e_n \gtRP}
            &= \gtLP x_1 \gtColon \intI{e_1}, x_2 \gtColon \intI{e_2}, \ldots, x_n \gtColon \intI{e_n} \gtRP \\
        \intI{\gtIf e_1 \gtThen e_2 \gtElse e_3}
            &= \gtIf \intI{e_1} \gtThen \intI{e_2} \gtElse \intI{e_3} \\
        \intI{e.x}
            &= \intI{e}.x \\
        \intI{\gtLet m \; x \gtAssign e_1 \gtIn e_2}
            &= \gtLet m \; x \gtAssign \intI{e_1} \gtIn \intI{e_2} \\
        \intI{x \gtAssign e}
            &= x \gtAssign \intI{e} \\
        \intI{\gtCase e_1 \gtOf \gtLB \gtSome x \gtArrow e_2 \gtRB \gtLB \gtNone \gtArrow e_3 \gtRB}
            &= \gtCase \intI{e_1} \gtOf \gtLB \gtSome x \gtArrow \intI{e_2} \gtRB
                \gtLB \gtNone \gtArrow \intI{e_3} \gtRB \\
        \intI{\gtBind e_1 \gtAs b \gtIn e_2}
            &= \gtBind \intI{e_1} \gtAs b \gtIn \intI{e_2} \\
        \intI{e}
            &= e \;\; \text{otherwise.}
    \end{align}

    \subsection{\texttt{C++} Generation}

    Following the imperative transformation, \texttt{C++} code generation takes place through
    stringification. This is done as follows:
\end{document}
