\documentclass{article}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{stmaryrd}
\usepackage{fullpage}
\usepackage{K3-Reference}

\title{K3: Language Reference}
\author{}
\date{}

\newcommand{\K}{\texttt{K3}}

\begin{document}
    \maketitle

    \tableofcontents

    \section{Code Generation}
    \subsection{Imperative Targets}

    Code generation to imperative target languages is done in two stages. The first is a pure $\K
    \rightarrow \K$ transformation which produces an imperative embedding, more amenable to
    translation into an imperative language. The second stage consists of the actual translation to
    the backing language.

    \subsubsection{Grammar Constructs}

    The rewrite rules for the first stage are as follows:

    \subsubsection{Declaration Rules}

    \begin{itemize}
        \item Triggers rewrite to functions of the corresponding argument types.
        \item Global variable declarations rewrite to declarations of the same type, with the caveat
            that collection declarations are rewritten to be of a type specific to the combination
            of annotations they are declared with.
        \item Annotation declarations rewrite to global declaration of composites, which consist of
            the relevant lifted attributes and methods.
    \end{itemize}
%
    \begin{align*}
        \eqI{\gtDeclare x \gtColon \tau \gtIs e}
            {\gtDeclare x \gtColon \tau \gtIs \intI{e}}
            {if $\tau$ is not a collection type.} \\
        \eqI{\gtDeclare x \gtColon \tau \gtIs e}
            {\gtDeclare x \gtColon \gtNamed \ConstructComposite{ids} \gtIs \intI{e}}
            {if $\tau \sim \gtCollection \gtAt \{ids\}$.} \\
        \eqI{\gtTrigger x \gtColon \tau \gtIs e}
            {\gtDeclare x \gtColon \tau \gtArrow \gtLP \gtRP \gtIs e}
            {} \\
        \eqI{\gtAnnotation A \gtGiven \gtLP t_1 \gtComma \ldots \gtComma t_n \gtRP \gtLB \bar{D} \gtRB}
            {\gtAnnotation A \gtGiven \gtLP t_1 \gtComma \ldots \gtComma t_n \gtRP \gtLB \intI{\bar{D}} \gtRB}{} \\
        \eqI{\gtProvides \gtLifted x \gtColon \tau \gtIs e}
            {\gtProvides \gtLifted x \gtColon \tau \gtIs \intI{e}}{} \\
        \eqI{\gtRequires \gtLifted x \gtColon \tau}
            {\gtRequires \gtLifted x \gtColon \tau}{} \\
        \eqI{\gtProvides x \gtColon \tau \gtIs e}
            {\gtProvides x \gtColon \tau \gtIs \intI{e}}{} \\
        \eqI{\gtRequires x \gtColon \tau}
            {\gtRequires x \gtColon \tau}{} \\
        \eqI{\gtProvides \gtAnnotation a}
            {\gtProvides \gtAnnotation a}{} \\
        \eqI{\gtRequires \gtAnnotation a}
            {\gtRequires \gtAnnotation a}{}
    \end{align*}

    \subsubsection{Expression Rules}

    \begin{itemize}
        \item Value constructors (constants of any type, \texttt{Some}/\texttt{None}, indirections,
            literal tuples and records, \texttt{empty}) should be reified with a generated name.
        \item Binary operators except function application can remain as-is.
        \item Function declaration/application has two forms:
            \begin{itemize}
                \item If the function is anonymous (and is therefore immediately applied), it should
                    be rewritten as a \texttt{let-in}.
                \item If the function is declared globally (and is therefore potentially applied
                    multiple times), it should be translated into a native function, with
                    corresponding invocations translated as native function calls.
            \end{itemize}
    \end{itemize}
%
    \begin{align*}
        \eqI{e_1 \oplus e_2}{\intI{e_1} \oplus \intI{e_2}}{where $\oplus \neq \epsilon$ or $e_1$ is a variable.} \\
        \eqI{\gtLP \lambda x \gtArrow e_1 \gtRP e_2}{\gtLet x \gtAssign \gtImmut \intI{e_2} \gtIn \intI{e_1}}{} \\
        \eqI{\gtSome e}{\gtSome \intI{e}}{} \\
        \eqI{\gtInd e}{\gtInd \intI{e}}{} \\
        \eqI{\gtLP e_1, e_2, \ldots, e_n \gtRP}{\gtLP \intI{e_1}, \intI{e_2}, \ldots, \intI{e_n} \gtRP}{} \\
        \eqI{\gtLP x_1 \gtColon e_1, x_2 \gtColon e_2, \ldots, x_n \gtColon e_n \gtRP}
            {\gtLP x_1 \gtColon \intI{e_1}, x_2 \gtColon \intI{e_2}, \ldots, x_n \gtColon \intI{e_n} \gtRP}{} \\
        \eqI{\gtIf e_1 \gtThen e_2 \gtElse e_3}{\gtIf \intI{e_1} \gtThen \intI{e_2} \gtElse \intI{e_3}}{} \\
        \eqI{e.x}{\intI{e}.x}{} \\
        \eqI{\gtLet x \gtAssign e_1 \gtIn e_2}{\gtLet x \gtAssign \intI{e_1} \gtIn \intI{e_2}}{} \\
        \eqI{x \gtAssign e}{x \gtAssign \intI{e}}{} \\
        \eqI{\gtCase e_1 \gtOf \gtLB \gtSome x \gtArrow e_2 \gtRB
                \gtLB \gtNone \gtArrow e_3 \gtRB}
            {\gtCase \intI{e_1} \gtOf \gtLB \gtSome x \gtArrow \intI{e_2} \gtRB
                \gtLB \gtNone \gtArrow \intI{e_3} \gtRB}
            {} \\
        \eqI{\gtBind e_1 \gtAs b \gtIn e_2}{\gtBind \intI{e_1} \gtAs b \gtIn \intI{e_2}}{} \\
        \eqI{e}{e}{otherwise.}
    \end{align*}

    \subsection{\texttt{C++} Generation}

    Following the imperative transformation, \texttt{C++} code generation takes place through
    stringification. This process references existing environments; $\Delta$ is the set of names
    currently in scope, along with their types and initial values, $\Gamma$ is the set of
    encountered combinations of annotations, to generate their corresponding interfaces and
    implementations, and $\rho$ is the set of encountered record types, for the same purpose.

    \subsubsection{Expression Rules}
%
    \begin{align*}
        \eqC{\gtSome e}{x \gtAssign \intC{e} \gtComma \gtAmp x}{} \\
        \eqC{\gtInd e}{x \gtAssign \intC{e} \gtComma \gtAmp x}{} \\
        \eqC{\gtLP e_1 \gtComma \ldots \gtComma e_n \gtRP}
            {\ccall{make\_tuple}{}{\intC{e_1}, \ldots, \intC{e_n}}}
            {} \\
        \eqC{\gtLB x_1 \gtColon e_1 \gtComma \ldots \gtComma x_n \gtColon e_n \gtRB}
            {\ConstructRecord{x_1, \ldots x_n} \gtLP \intI{e_1} \gtComma \ldots \gtComma \intI{e_n} \gtRP}{} \\
        \eqC{e_1 \oplus e_2}{\intC{e_1} \oplus \intC{e_2}}{} \\
        \eqC{e \gtDot x}{\intC{e} \gtDot x}{} \\
        \eqC{\gtLet x \gtAssign e_1 \gtIn e_2}
            {x \gtAssign \intC{e_1} \gtComma \intC{e_2}}
            {when $x \in \Delta$} \\
        \eqC{x \gtAssign e}{x \gtAssign \intC{e}}{} \\
        \eqC{\gtCase e_1 \gtOf \gtLB \gtSome x \gtArrow e_2 \gtRB \gtLB \gtNone \gtArrow e_3 \gtRB}
            {y \gtAssign \intC{e_1} \gtComma
                \gtLP y \gtNeq \tk{null} \gtRP \gtQt
                \gtLP x \gtAssign \gtStar y \gtComma \intC{e_2} \gtRP \gtColon
                \intC{e_3}
            }
            {} \\
        \eqC{\gtBind e_1 \gtAs \gtInd x \gtIn e_2}
            {y \gtAssign \intC{e_1} \gtComma x \gtAssign \gtAmp y \gtComma \intC{e_2}}
            {when $x, y \in \Delta$.} \\
        \eqC{\gtBind e_1 \gtAs \gtLP x_1, \ldots, x_n \gtRP \gtIn e_2}
            {y \gtAssign \intC{e_1} \gtComma
                x_1 \gtAssign \ccall{get}{0}{y} \gtComma \ldots \gtComma
                x_n \gtAssign \ccall{get}{n - 1}{y} \gtComma
                \intC{e_2}
            }{when $x_1, \ldots, x_n \in \Delta$.} \\
        \eqC{\gtBind e_1 \gtAs \gtLB x_1 \gtColon z_1 \gtComma \ldots \gtComma x_n \gtColon z_n \gtRB \gtIn e_2}
            {y \gtAssign \intC{e_1} \gtComma
                z_1 \gtAssign y \gtDot x_1 \gtComma \ldots \gtComma
                z_n \gtAssign y \gtDot x_n \gtComma
                \intC{e_2}}
            {when $z_1, \ldots z_n \in \Delta$} \\
        \eqC{\gtIf e_1 \gtThen e_2 \gtElse e_3}{\intC{e_1} \gtQt \intC{e_2} \gtColon \intC{e_3}}{} \\
    \end{align*}

    \subsubsection{Declaration Rules}
\end{document}
